sdi1800064 THOMAS KARAGIANNIS

Καλησπέρα, σας παρουσιάζω την εργασία για τα Λειτουργικά Συστήματα 1.

Αρχικά να ξεκινήσω με την εξής πληροφορία. Στο πρόγραμμα που σας παραουσιάζω δεν γίνεται
σωστή λειτουργία του Γραμμικού Κατακερματισμού. Ωστόσο λόγω της προσπάθειας μου και του χρόνου 
που έχω επενδύσει στο Project αυτό σκέφτηκα σωστό να σας το παρουσιάσω με αυτή την έκδοση Κατακερματισμού
και ας μην γίνεται σωστά η διαχείρηση μέσα στο table. Σε δέυτερη φάση το πρόγραμμα παίρνει ως δεδομένο
ότι το αρχείο είναι της μορφής <PIN> <LAST NAME> <FIRST NAME> <ZIP CODE>.

Ας τα παρουμε τα πραγματα με τη σειρά.

Η main μου ξεκινάει με έναν έλεγχω για να δει αν έχει γίνει σωστή εισαγωγή των παραμέτρων.(όνομα αρχείου
και εισαγωγή βάθους των buckets σε ακέραιο)
Στη συνέχεια διαβάζει μία μία τις γραμμές του αρχείου και εισαγάγει τον συμμετέχοντα, με τα στοιχεία
που διάβασε, στο τραπέζι. Εκτυπώνει τη λίστα με τις εντολές που μπορεί να χρησιμοποιήσει ο χρήστης με τη μορφή τους.
Ελέγχει ποιά εντολή χρησιμοποίησε ο χρήστης και την ορθότητα της με τη χρήση της εντολής strcpm().
Εκτυπώνει ανάλογα μηνύματα. Στο τέλος της main γίνεται απελευθέρωση μνήμης.

Στο αρχείο hashTable.c έχουμε τις βασικές συναρτήσεις που χρησιμοποιούνται για τη διαχείρηση του hashTable.

Πρώτη έχουμε τη συνάρτηση αρχικοποίησης του table. Εδώ αρχικοποιούντε οι διάφορες μεταβλητές που 
έχει η δομή μας και δεσμέυεται ο απαραίτητος χώρος τόσο για το τραπέζι όσο και για τα arrays 
των αρχικών buckets και τα arrays από participants και των κουβάδων υπερχύλησης αυτών.

Στη συνέχεια βλέπουμε δύο συναρτήσεις hash εκ των οποίων η hashFunction εχει τον ρόλο της συνάρτησης για 
το επίπεδο στο οποίο βρισκόμαστε και η reHashFunction αυτόν του level + 1. Το hash υπολογίζεται από την 
ολίσθηση προς τα αριστερά της μονάδας κατά όσο ειναι το επίπεδο που θέλουμε.

Υπάρχει μια getParticipant συνάρτηση, η οποία επιστρέφει έναν δείκτη στον participant του οπίου το κλειδί
εισαγάγαμε. Αυτό γίνεται πρώτα με τον προσδιορισμό του κουβά που ανήκει με τη χρήση της hashFunction, και
στη συνέχεια με τον έλεγχο αν υπάρχουν κουβάδες υπερχύλησης. Αν υπάρχουν, ψάχνουμε ελέγχουμε μήπως υπάρχει 
πρώτα σε αυτόυς και στη συνέχεια αν υπάρχει στον κύριο κουβά. Αν δεν υπάρχουν, ελέγχουμε κατευθείαν τον κύριο.

Υπάρχει μια συνάρτηση insert, υπέυθυνη για την εισαγωγή των στοιχείων στο hashTable. Σε αυτή,
παίρνουμε αρχικά το σωστό hash ελέγχοντας που βρίσκεται ο split pointer p και κοιτάμε αν υπάρχει ήδη 
στο τραπέζι στον κουβα που προορίζεται ή σε καποιον υπερχύλησης. Αν δεν υπάρχει, ελέγχουμε αν 
ο κύριος κουβάς είναι γεμάτος. Αν δεν είναι, τον προσθέτουμε εκεί. Αν είναι, ελέγχουμε αν υπάρχει
κουβάς υπερχύλησης. Αν δεν υπάρχει τον αρχικοποιούμε και προχωράμε στην εισαγωγή. Εισαγάγουμε τον participant 
στον πιο πρόσφατο overflow bucket. Αν μετα την εισαγωγή γεμίσει, φτιάχνουμε έναν κανούριο. Αφού ολοκληρωθεί
όλη η διαδικασία της εισαγωγής, ελέγχουμε αν η πληρότητα ξεπέρασε το 0.75 και καλόυμε τη συνάρτηση split.

Συνάρτηση split. Σε αυτή , αυξάνουμε τον αριθμό των κύριων κουβάδων στο τραπέζι, και επαναδεσμέυουμε αρκετή
μνήμη. Αρχικοποιούμε τον καινούριο κουβά. Ελέγχουμε αν υπάρχουν κουβάδες υπερχύλησης. Αν υπάρχουν,
δημιουργόυμε έναν προσωρινό πίνακα στον οποίο αντιγράφουμε όλους τους particpants που υπαρχουν στους κουβαδες αυτούς.
Ελευθερώνουμε τη μνήμη των κουβάδων υπερχύλησης και συνεχίζουμε στην επανεισαγωγή των participants από τον πίνακα.
Αν δεν υπάρχουν κουβάδες υπερχύλησης, κάνουμε την ίδια διαδικασία επανεισαγωγής χωρίς τον έλεγχο για κουβάδες υπερχύλησης.

Συνάρτηση reInsert. Ακολουθεί παρόμοια φιλοσοφία με αυτή της insert(Εδώ γίνεται και ένας περιτός έλεγχος για κουβάδες
υπερχύλησης. Περιττός γιατί όπως προανέφερα αδειάζονται οι κουβάδες απο τους οποίους γίνεται το split) χωρίς βέβαια
να γίνεται έλεγχος πληρότητας του τραπεζιού.

Συνάρτηση freeHashTable. Σε αυτη γίνεται προσπέλαση όλων των κουβάδων του τραπεζιού και γίνονται free όλα τα overflow buckets 
και οι participants αυτων, οι participants των main buckets καθως και τα ίδια τα main buckets ακολουθούμενα, τέλος,
μόνο από το ίδιο το τραπέζι Κατακερματισμού.

Στο αρχείο zipList.c βλέπουμε όλες τις συναρτήσεις που αφορούν την διαδικασία ψήφου και τη δημιουργία και εκτύπωση της λίστας
των ταχυδρομικών κωδικών.

Βλέπουμε τη συνάρτηση addToList στην οποία φτίαχνουμε ένα καινούριο participantNode το οποίο αν η λίστα μας είναι κενή
ια γίνει το κεφάλι, αλλιώς ψαχνούμε να βρούμε το τελεταίο node της λιστα, και το προσθέτουμε εκεί.

Στη συνάρτηση changeVote, παίνουμε τον participant του οποίου θέλουμε να αλλάξουμε την κατάσταση ψήφου του με τη βοήθεια της getParticipant.
Αν ο particpant υπάρχει, ελέγχουμε αν έχει ήδη ψηφίσει. Αν όχι, αλλάζουμε την κατάσταση του, και ψάχνουμε να δούμε αν ο ταχιδρομικός
του κώδικας υπάρχει στη λίστα μας. Αν υπάρχει τον προσθέτουμε στο node που αντιστοιχεί σε αυτον τον ταχιδρομικό κώδικα.
Αν οχι, δημιουργούμε ένα καινούριο node που αντιστοιχεί σε αυτόν τον ταχιδρομικό κώδικα, ελέγχουμε αν η λιστα είναι κενή
και προσθέτουμε τον particpant εκεί. Αλλιώς επιστρεφουμε κατάλληλο μήνυμα.

Στην printZIPList προσπελάσουμε την λίστα, και εκτυπώνουμε το zip code από το κάθε node που έχει.

Στην printPartZip ψάχνουμε αν υπάρχει ο ταχυδρομικός κώδικας που δώθηκε, και αν υπάρχει εκτυπώνουμε τον αριθμό από participants
που αντιστοιχούν σε αυτόν, και του εκτυπώνουμε.

Στην printZIPListDescending εκτυπώνουμε τη λίστα σε φθήνουσα σειρά. Αρχικά περνάμε τη λίστα μια φορά για να βρούμε τον μεγαλύρο zip code.
Στη συνέχια με τη χρήση της for loop περάμε τη λίστα όσες φορές χρειάζεται για να εκτυπώσουμε όλα τα zip codes. (Το γνωρίζω οτι ειναι πολύ
χρονοβόρο αλλα λόγω έλειψης χρόνου δεν πρόλαβα να κάνω την εκδοχή όπου τα zip code nodes προστίθεντε στη λλίστα αυτομάτως σε φθίνουσα σειρά.)

Τέλος υπάρχει μία συνάρτηση για απελευθέρωση της μνήμης που έχει δεσμέυσει η λίστα.

Ευχαριστώ για τον χρόνο σας.



Υ.Γ

Επειδή μου έχει πάρει υπερβολικά πολυ χρόνο να βρω τον λόγο που δεν δουλεύει το linear hash table, θα γινόταν να γίνει μια ενημέρωση
με την σωστή υλοποίηση; που έχει παρει 6 μέρες και ακόμα δεν έχω βγάλει άκρη του τι κάνω λάθος. Στο valgrind φαίνεται οτι διαβάζεται 
και γράφεται πληροφορία πάνω σε invalid memory αλλά δεν μπορώ να καταλάβω που κάνω το λογικό λάθος και βγαίνει αυτό το αποτέλεσμα.
Το email μου είναι thomaskaragiannis@hotmail.gr ή της σχολής sdi1800064@di.uoa.gr .
Ένα οποιοδήποτε point προς τη σωστή κατεύθηνση θα ήταν καταπληκτικό.